TERMINAL / BASH NOTES
* Basics
** ARGUMENTS - Are separated by 'white space'
      - 'space' characters must be escaped if you want the space not to
        separate things. ex. 'john\ doe'
** RELATIVE / ABSOLUTE PATHS
      - If you are making a program that has to run in a situation where
        files may not be organized the same way, a relative path will end up
        breaking.  In this case an absolute path, or simply the name of the
        program will be a better choice.  Even in web developement, I think
        it may be prudent to design my website so that a simple
        re-organization of files doesn't break the entire website.  I suppose
        having a template for file organization could help with this too.
        More research is necessary in this case.
* Basic Commands
** mv [move]
      - 'sudo mv' (if you want to move a folder with contents)
      - no modifiers needed. It is already recursive
      - can be used to rename files

** <, >, << >> (double carrot 'appends' instead of overwriting.)
      - '<' push to standard input 'STDIN'
      - '>' push to standard output 'STDOUT'
      - cat < hello.txt > hello2.txt (this will take the contents of the
        first file and print it within the second file)
** su (sudo su) [switch user]
      - 'sudo su' - if you want to switch to 'root' user. BE CAREFUL!
** tee (write to file AND stdout)
      - echo test | tee file.txt [this will output 'test' to file.txt and to
        stdout]
** xdg-open (open file with the proper program)
      - 'xdg-open text.txt' will open test.txt in text editor. If you only
        use 'open text.txt' it will use the terminal(probably?).
** variables
      - foo=bar (no spaces 'foo = bar' would not work.)
      - echo $foo (result= bar)
** strings
      - echo "hello world $foo" prints> hello world bar
      - echo 'hello world $foo' prings> hello world $foo
** running files
      - xdg-open <filename> (opens file with the proper program)
** grep (search for something in a file or from an input)
      - grep -flags 'content to search for' <filename>
** find (find files)
      - explanation here. :p
** defineing functions (This will now work anywhere IN YOUR CURRENT SESSION)
      - ex. below is a function that will make a new directory and cd into
        it.
      - 
      - mcd () {
      - mkdir -p "$1"
      - cd "$1"
      - }
      - 
      - mcd testFolder
      - RESULT = A folder called 'testFolder' will be made and you will be
        cd'd into that folder.
** $?
      - standard error (stder)
** $0
      - Self (name of the script)
** $#
      - number of arguments fed to the process
** $$
      - pid - process id
** ; (use to chain opperations together separate from eachother.)
      - ex. false ; echo "this will still print!"
      - ex. echo "this" ; echo "that"     [both will run and print]
** cat (concatonate)(join strings || files)(output is as a file)
      - cat <(ls) <(ls ..)
      - Some opperations expect a file NOT from stdout SO since cat outputs
        a file essentially, you can use it for those operations.

** loops
      - for loops example
#!/bin/bash

echo "Starting program at $(date)" # Date will be substituted

echo "Running program $0 with $# arguments with pid $$"

for file in "$@"; do
  grep foobar "$file" > /dev/null 2> /dev/null
  # When pattern is not found, grep has exit status 1
  # We redirect STDOUT and STDERR to a null register since we do not care about them.
  if [[ $? -ne 0]]; then
    echo "File $file does not have any foobar, adding one now"
    echo "# foobar" >> "$file"
  fi
done
** globbing
      - *.sh (This means any file with a '.sh' file type)
      - project? (similar thing but with any something afterwards)
** expansion
      - touch test{1,2} (This makes two files -> test1 & test2)
** find
      - find . -path '**/*.txt' -type f (find [in current dir.][this path-any
        number of files-any name ending in .txt][type = file])
      - find . -name ting* -type d (find [in current dir.][-name?][partof
        filename *=any pattern following][type directory])
      - find . -name "*.tmp" -exec rm [] \;  (find all temp files and remove
        them)
      - find . -name "*.tmp"   =>   fd ".*tmp" (there are shorter ways using
        regex)
      - 
